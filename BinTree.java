/****************************************************** * @author Christian Nwafor * Lab: 4 * Date: 1/12/2016 * Description: THIS IS THE BINTREE CLASS ******************************************************/// BinTree class//// this class implements a binary tree//// the tree is unbounded. fields are//     info: the value stored in the node (generic type)//     left:   pointer to the left subtree//     right:  pointer to the right subtree//     parent: pointer to the parent//     preOrderQueue: queue of nodes for preorder traversal//// left, right, and parent are public to allow the client code// to manipulate the tree as needed//// methods://     constructor to create empty tree//     constructor to create tree with one node//     constructor to create tree given the root value, and//          pointers to the left and right subtrees//     get and set methods for the info field//     isEmpty//     attachLeft:  if there is no left child, attach the given tree as//                  the new left child; otherwise throw TreeViolationException//     attachRight: if there is no right child, attach the given tree as//                  the new right child; otherwise throw TreeViolationException//     detachLeft:  detach and return the left child//     detachRight: detach and return the right child//     root:        return the root of the treepublic class BinTree<T> implements BinTreeInterface<T> {    protected T info;    public BinTree<T> left;    public BinTree<T> right;    public BinTree<T> parent;    private LinkedUnbndQueue<T> preOrderQueue;    // create an empty tree    public BinTree() {        info = null;        left = null;        right = null;        parent = null;    }    // create a tree with one node    public BinTree(T item) {    	this.info = item;    	this.left = null;    	this.right = null;    	this.parent = null;    }    // create a tree where the root contains item    // link the left and right subtrees to the root    // don't forget to set the parent pointers    public BinTree(T item, BinTree<T> ltree, BinTree<T> rtree) throws TreeViolationException{    	this.info = item;    	this.attachLeft(ltree);    	this.attachRight(rtree);    	ltree.parent = this;    	rtree.parent = this;    }    // return the info field    public T getInfo() {        return info;    }    // set the info field    public void setInfo(T newitem) {        info = newitem;    }    // attach the parm as the left child of the current node    // throw TreeViolationException if the current node already has a left child    public void attachLeft(BinTree<T> tree) throws TreeViolationException{    	if (this.left != null)    		throw new TreeViolationException(" A left child already exists");    	else{    		this.left = tree;    		left.parent = this;    	}    }    // attach the parm as the right child of the current node    // throw TreeViolationException if the current node already has a right child    public void attachRight(BinTree<T> tree) throws TreeViolationException{    	if (this.right != null)    		throw new TreeViolationException(" A right child already exists");    	else {    		this.right = tree;    		right.parent = this;    	}    }    // detach the left child and return it    public BinTree<T> detachLeft() {    	BinTree <T> keepLeft = this.left;      	this.left = null;    	    	return keepLeft;    }    // detach the right child and return it    public BinTree<T> detachRight() {    	BinTree <T> keepRight = this.right;    	      	this.right = null;    	    	return keepRight;    }    // return the root of the tree (follow the parent links)    public BinTree<T> root() {    	if (parent == null)    		return this;    	else    		return parent.root();    }    // Initializes preOrderQueue with tree elements in preOrder order.    public void preOrder(BinTree<T> tree)  {        if (tree != null) {            preOrderQueue.enqueue(tree.getInfo());            preOrder(tree.left);            preOrder(tree.right);        }    }    // calls preorder to create queue of nodes in the tree    public void reset()  {      preOrderQueue = new LinkedUnbndQueue<T>();      preOrder(this);    }    // removes and returns the next node in the preorder queue    // returns null if the queue is empty    public T getNext()  {        if (preOrderQueue.isEmpty())            return null;        else            return preOrderQueue.dequeue();    }}